# Phase 2.1: Clear Announces Preserves Contacts - Research

**Researched:** 2026-01-27
**Domain:** Room Database Query Modification (Kotlin/Android)
**Confidence:** HIGH

## Summary

This is a codebase-internal bug fix requiring a single Room DAO query modification. The current `deleteAllAnnounces()` method unconditionally deletes all rows from the `announces` table. The fix requires modifying the SQL query to exclude announces where `destinationHash` exists in the `contacts` table for the active identity.

**Key findings:**
- **Data model is well-structured**: Both `AnnounceEntity` and `ContactEntity` share `destinationHash` as the linking field
- **Simple SQL fix**: Need to add a `WHERE` clause with a `NOT IN` subquery to exclude contact-owned announces
- **Identity context exists**: Contact table is scoped by `identityHash`, so we need to filter by the active identity
- **Call chain is clear**: UI → ViewModel → Repository → DAO (4 layers, all identified)

**Primary recommendation:** Modify `AnnounceDao.deleteAllAnnounces()` to accept an `identityHash` parameter and use a SQL subquery to exclude contact announces. Update the call chain to pass the active identity hash from ViewModel to DAO.

## Standard Stack

This phase uses existing project infrastructure - no new libraries needed.

### Core
| Component | Purpose | Already In Project |
|-----------|---------|-------------------|
| Room | SQLite ORM for database operations | Yes, v2.6.1 |
| Kotlin Coroutines | Async database operations | Yes, v1.9.0 |
| Hilt | Dependency injection | Yes, v2.51.1 |
| JUnit 4 + MockK | Testing framework | Yes |

### Architecture Pattern Used
- **Repository Pattern**: Data layer abstraction (already in use)
- **DAO Pattern**: Direct database access (Room)
- **Unidirectional Data Flow**: ViewModel → Repository → DAO → Database

## Architecture Patterns

### Current Structure (Identified in Codebase)

```
UI Layer:
├── AnnounceStreamScreen.kt (line 380: viewModel.deleteAllAnnounces())
└── ContactsScreen.kt (line 153: showClearAllAnnouncesDialog trigger)

ViewModel Layer:
├── AnnounceStreamViewModel.kt (line 476-485: deleteAllAnnounces() function)
└── identityRepository: IdentityRepository (available for getActiveIdentitySync())

Repository Layer:
├── AnnounceRepository.kt (line 397-399: deleteAllAnnounces() function)
└── ContactRepository.kt (not used in this fix, but contacts defined here)

DAO Layer:
├── AnnounceDao.kt (line 131-132: deleteAllAnnounces() - THE FIX LOCATION)
└── ContactDao.kt (shows pattern for identity-scoped queries)

Database:
├── announces table (PK: destinationHash)
└── contacts table (PK: destinationHash + identityHash)
```

### Pattern 1: Room DAO Query with Subquery Exclusion

**What:** Use SQL `WHERE NOT IN (SELECT ...)` to exclude announces owned by contacts

**When to use:** When deleting records that should exclude items matching a foreign relationship

**Example from ContactDao (line 37-78):**
```kotlin
@Query("""
    SELECT c.*
    FROM contacts c
    LEFT JOIN announces a ON c.destinationHash = a.destinationHash
    WHERE c.identityHash = :identityHash
""")
fun getEnrichedContacts(identityHash: String): Flow<List<EnrichedContact>>
```

**Pattern for this fix:**
```kotlin
@Query("""
    DELETE FROM announces
    WHERE destinationHash NOT IN (
        SELECT destinationHash
        FROM contacts
        WHERE identityHash = :identityHash
    )
""")
suspend fun deleteAllAnnouncesExceptContacts(identityHash: String)
```

### Pattern 2: Identity-Scoped Operations

**What:** Operations that filter by active identity to maintain data isolation

**When to use:** Any operation involving user-specific data (contacts are identity-scoped)

**Example from AnnounceStreamViewModel (line 361):**
```kotlin
val displayName = identityRepository.getActiveIdentitySync()?.displayName ?: "Unknown"
```

**Pattern for this fix:**
```kotlin
fun deleteAllAnnounces() {
    viewModelScope.launch {
        try {
            val activeIdentity = identityRepository.getActiveIdentitySync()
            if (activeIdentity != null) {
                announceRepository.deleteAllAnnouncesExceptContacts(activeIdentity.identityHash)
            } else {
                // Fallback: delete all if no active identity (shouldn't happen)
                announceRepository.deleteAllAnnounces()
            }
            Log.d(TAG, "Deleted non-contact announces")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to delete announces", e)
        }
    }
}
```

### Anti-Patterns to Avoid

- **Don't fetch all contacts to filter in Kotlin**: The WHERE clause in SQL is far more efficient than loading all data into memory
- **Don't iterate and delete individually**: A single SQL DELETE with subquery is atomic and faster
- **Don't forget the identity context**: Contacts are scoped to identities, so must filter by `identityHash`

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Identity resolution | Manual identity fetching in multiple places | Use existing `identityRepository.getActiveIdentitySync()` | Already tested and handles edge cases |
| Contact-announce linking | Custom join logic | Room's native SQL support with subqueries | Atomic, efficient, and type-safe |
| Error handling | Custom try-catch everywhere | Existing ViewModel pattern (already logs errors) | Consistent error handling across app |

**Key insight:** This is a SQL query change, not a new feature. Use Room's @Query annotation capabilities rather than building custom logic.

## Common Pitfalls

### Pitfall 1: Forgetting Identity Context

**What goes wrong:** Deleting announces that match ANY contact, not just contacts for the active identity

**Why it happens:** The `contacts` table has composite primary key `(destinationHash, identityHash)`, meaning the same destinationHash can appear for multiple identities

**How to avoid:** Always include `WHERE identityHash = :identityHash` in the contact subquery

**Example of WRONG query:**
```kotlin
@Query("""
    DELETE FROM announces
    WHERE destinationHash NOT IN (SELECT destinationHash FROM contacts)
""")
```
This would preserve announces for contacts belonging to OTHER identities too!

**Example of CORRECT query:**
```kotlin
@Query("""
    DELETE FROM announces
    WHERE destinationHash NOT IN (
        SELECT destinationHash FROM contacts WHERE identityHash = :identityHash
    )
""")
suspend fun deleteAllAnnouncesExceptContacts(identityHash: String)
```

**Warning signs:** Test with multiple identities. If Identity A's contacts prevent deletion but Identity B is active, the query is wrong.

### Pitfall 2: Breaking the Existing deleteAllAnnounces()

**What goes wrong:** Tests or other code paths that call `deleteAllAnnounces()` for legitimate reasons (like test cleanup) break

**Why it happens:** Changing the signature of existing method without checking all call sites

**How to avoid:**
- Option A: Keep old `deleteAllAnnounces()` and add new `deleteAllAnnouncesExceptContacts(identityHash)`
- Option B: Change `deleteAllAnnounces()` to optionally take `identityHash` parameter with default null
- Option C: Keep old method for tests, rename production call to new method

**Recommendation:** Use Option A for clarity - two separate methods with clear intent

**Warning signs:** Run test suite after change. If AnnounceStreamViewModelTest fails, you broke the old method.

### Pitfall 3: Race Condition with Contact Deletion

**What goes wrong:** User deletes a contact while "Clear All Announces" is executing

**Why it happens:** Two database operations in separate transactions

**How to avoid:** This is acceptable behavior - Room transactions are atomic. If contact is deleted before clear executes, its announce will be deleted. If deleted after, announce is preserved. Both outcomes are correct.

**Warning signs:** None - this is not a bug, it's expected eventual consistency.

### Pitfall 4: Null Active Identity

**What goes wrong:** User has no active identity (edge case during identity switching or first run)

**Why it happens:** `getActiveIdentitySync()` can return null

**How to avoid:** Add null check in ViewModel and decide behavior:
  - Option A: Delete nothing (safer)
  - Option B: Delete all (original behavior)
  - Option C: Show error message

**Recommendation:** Option B (delete all) for backward compatibility. No active identity means no contacts are relevant anyway.

**Warning signs:** Test with identity switching and fresh app install.

## Code Examples

### Change 1: DAO Layer (AnnounceDao.kt)

**Current implementation (line 131-132):**
```kotlin
/**
 * Delete all announces (for testing/debugging)
 */
@Query("DELETE FROM announces")
suspend fun deleteAllAnnounces()
```

**New implementation:**
```kotlin
/**
 * Delete all announces (for testing/debugging)
 */
@Query("DELETE FROM announces")
suspend fun deleteAllAnnounces()

/**
 * Delete all announces except those belonging to contacts of the specified identity.
 * Preserves contact announces so users can still open conversations with saved contacts.
 *
 * @param identityHash The identity hash to filter contacts by
 */
@Query("""
    DELETE FROM announces
    WHERE destinationHash NOT IN (
        SELECT destinationHash
        FROM contacts
        WHERE identityHash = :identityHash
    )
""")
suspend fun deleteAllAnnouncesExceptContacts(identityHash: String)
```

**Rationale:** Keep original method for test compatibility, add new method for production use.

### Change 2: Repository Layer (AnnounceRepository.kt)

**Current implementation (line 397-399):**
```kotlin
/**
 * Delete all announces (for testing/debugging)
 */
suspend fun deleteAllAnnounces() {
    announceDao.deleteAllAnnounces()
}
```

**New implementation:**
```kotlin
/**
 * Delete all announces (for testing/debugging)
 */
suspend fun deleteAllAnnounces() {
    announceDao.deleteAllAnnounces()
}

/**
 * Delete all announces except those belonging to contacts of the specified identity.
 * Preserves contact announces so users can still open conversations with saved contacts.
 *
 * @param identityHash The identity hash to filter contacts by
 */
suspend fun deleteAllAnnouncesExceptContacts(identityHash: String) {
    announceDao.deleteAllAnnouncesExceptContacts(identityHash)
}
```

### Change 3: ViewModel Layer (AnnounceStreamViewModel.kt)

**Current implementation (line 476-485):**
```kotlin
/**
 * Delete all announces from the database.
 * Nodes will reappear when they announce again.
 */
fun deleteAllAnnounces() {
    viewModelScope.launch {
        try {
            announceRepository.deleteAllAnnounces()
            Log.d(TAG, "Deleted all announces")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to delete all announces", e)
        }
    }
}
```

**New implementation:**
```kotlin
/**
 * Delete all announces from the database, except those belonging to saved contacts.
 * Preserves announces for contacts so users can still open conversations.
 * Nodes will reappear when they announce again.
 */
fun deleteAllAnnounces() {
    viewModelScope.launch {
        try {
            val activeIdentity = identityRepository.getActiveIdentitySync()
            if (activeIdentity != null) {
                announceRepository.deleteAllAnnouncesExceptContacts(activeIdentity.identityHash)
                Log.d(TAG, "Deleted non-contact announces for identity: ${activeIdentity.identityHash}")
            } else {
                // Fallback: delete all if no active identity (shouldn't happen in normal use)
                announceRepository.deleteAllAnnounces()
                Log.d(TAG, "Deleted all announces (no active identity)")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to delete announces", e)
        }
    }
}
```

**Rationale:** Use new method when active identity exists, fallback to old behavior if not.

### Change 4: UI Layer (Optional - Improve Dialog Text)

**Current implementation (AnnounceStreamScreen.kt line 853-856):**
```kotlin
title = {
    Text("Clear All Announces?")
},
text = {
    Text("This will remove all discovered nodes from the list. They will reappear when they announce again.")
},
```

**Improved implementation:**
```kotlin
title = {
    Text("Clear All Announces?")
},
text = {
    Text("This will remove all discovered nodes from the list, except those saved in My Contacts. Nodes will reappear when they announce again.")
},
```

**Rationale:** Update user-facing text to reflect the new behavior (preserves contact announces).

## Test Strategy

### Unit Tests to Add

**File:** `data/src/test/java/com/lxmf/messenger/data/db/dao/AnnounceDaoTest.kt` (new file)

**Test cases:**
1. `deleteAllAnnouncesExceptContacts removes non-contact announces`
2. `deleteAllAnnouncesExceptContacts preserves contact announces for active identity`
3. `deleteAllAnnouncesExceptContacts does not preserve contacts from other identities`
4. `deleteAllAnnouncesExceptContacts handles empty contacts table`
5. `deleteAllAnnouncesExceptContacts handles empty announces table`
6. `deleteAllAnnounces still works for test cleanup` (regression test)

**Test pattern (from TESTING.md):**
```kotlin
@OptIn(ExperimentalCoroutinesApi::class)
class AnnounceDaoTest {
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()

    private lateinit var database: ColumbaDatabase
    private lateinit var announceDao: AnnounceDao
    private lateinit var contactDao: ContactDao

    private val testIdentityHash = "identity123"
    private val testDestHash1 = "dest_hash_1"
    private val testDestHash2 = "dest_hash_2"

    @Before
    fun setup() {
        // Setup in-memory database for testing
        val context = ApplicationProvider.getApplicationContext<Context>()
        database = Room.inMemoryDatabaseBuilder(context, ColumbaDatabase::class.java)
            .allowMainThreadQueries()
            .build()
        announceDao = database.announceDao()
        contactDao = database.contactDao()
    }

    @After
    fun tearDown() {
        database.close()
    }

    @Test
    fun `deleteAllAnnouncesExceptContacts preserves contact announces`() = runTest {
        // Arrange: Insert 2 announces
        val announce1 = AnnounceEntity(
            destinationHash = testDestHash1,
            peerName = "Contact Node",
            publicKey = ByteArray(32) { 1 },
            appData = null,
            hops = 1,
            lastSeenTimestamp = System.currentTimeMillis(),
            nodeType = "PEER",
        )
        val announce2 = AnnounceEntity(
            destinationHash = testDestHash2,
            peerName = "Random Node",
            publicKey = ByteArray(32) { 2 },
            appData = null,
            hops = 2,
            lastSeenTimestamp = System.currentTimeMillis(),
            nodeType = "PEER",
        )
        announceDao.upsertAnnounce(announce1)
        announceDao.upsertAnnounce(announce2)

        // Add contact for announce1 only
        val contact = ContactEntity(
            destinationHash = testDestHash1,
            identityHash = testIdentityHash,
            publicKey = ByteArray(32) { 1 },
            addedTimestamp = System.currentTimeMillis(),
            addedVia = "ANNOUNCE",
        )
        contactDao.insertContact(contact)

        // Act: Delete non-contact announces
        announceDao.deleteAllAnnouncesExceptContacts(testIdentityHash)

        // Assert: Only contact announce remains
        val remaining = announceDao.getAllAnnouncesSync()
        assertEquals(1, remaining.size)
        assertEquals(testDestHash1, remaining[0].destinationHash)
    }
}
```

### Integration Test Pattern

**File:** `app/src/test/java/com/lxmf/messenger/viewmodel/AnnounceStreamViewModelTest.kt` (add to existing)

**Test case:**
```kotlin
@Test
fun `deleteAllAnnounces preserves contact announces`() = runTest {
    // Setup: Mock active identity and repository responses
    val testIdentityHash = "test_identity"
    coEvery { identityRepository.getActiveIdentitySync() } returns testLocalIdentity.copy(identityHash = testIdentityHash)
    coEvery { announceRepository.deleteAllAnnouncesExceptContacts(testIdentityHash) } just Runs

    // Create ViewModel
    viewModel = createViewModel()
    advanceUntilIdle()

    // Act: Call delete
    viewModel.deleteAllAnnounces()
    advanceUntilIdle()

    // Assert: Verify new method was called with correct identity
    coVerify { announceRepository.deleteAllAnnouncesExceptContacts(testIdentityHash) }
    coVerify(exactly = 0) { announceRepository.deleteAllAnnounces() }
}
```

## State of the Art

| Old Approach | Current Approach | Impact |
|--------------|------------------|--------|
| Unconditional DELETE FROM announces | DELETE with WHERE NOT IN subquery | Preserves contact announces |
| No identity context | Identity-scoped filtering | Multi-identity support |
| Simple deletion | Conditional deletion | Better UX (no "Node not found" errors) |

**No deprecated patterns involved** - this is a straightforward SQL enhancement to existing code.

## Open Questions

1. **Should pinned/favorited announces also be preserved?**
   - What we know: Current requirement only mentions contacts
   - What's unclear: User might expect favorited nodes to persist too
   - Recommendation: Stick to requirement (contacts only). Favoriting can be Phase 2.2 if needed.

2. **Should there be UI feedback showing how many announces were deleted?**
   - What we know: Current dialog just says "deleted all"
   - What's unclear: Whether users care about the count
   - Recommendation: Not required for this phase. Log it for debugging, but no UI change needed.

3. **What happens if a contact is in PENDING_IDENTITY state (no public key)?**
   - What we know: ContactEntity can have null publicKey (line 63 of ContactEntity.kt)
   - What's unclear: Does the announce still need to be preserved?
   - Recommendation: Yes, preserve it. The destinationHash still matters for identity resolution.

## Sources

### Primary (HIGH confidence)
- `/home/tyler/repos/public/columba/data/src/main/java/com/lxmf/messenger/data/db/entity/AnnounceEntity.kt` - Data model
- `/home/tyler/repos/public/columba/data/src/main/java/com/lxmf/messenger/data/db/entity/ContactEntity.kt` - Data model
- `/home/tyler/repos/public/columba/data/src/main/java/com/lxmf/messenger/data/db/dao/AnnounceDao.kt` - DAO methods
- `/home/tyler/repos/public/columba/data/src/main/java/com/lxmf/messenger/data/db/dao/ContactDao.kt` - Join pattern examples
- `/home/tyler/repos/public/columba/data/src/main/java/com/lxmf/messenger/data/repository/AnnounceRepository.kt` - Repository layer
- `/home/tyler/repos/public/columba/app/src/main/java/com/lxmf/messenger/viewmodel/AnnounceStreamViewModel.kt` - ViewModel layer
- `/home/tyler/repos/public/columba/app/src/main/java/com/lxmf/messenger/ui/screens/AnnounceStreamScreen.kt` - UI trigger
- `/home/tyler/repos/public/columba/.planning/codebase/TESTING.md` - Test patterns

### Secondary (MEDIUM confidence)
- GitHub Issue #365 - User-reported bug describing the problem
- Room documentation - Subquery patterns (implicit from existing code patterns)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All dependencies already in project
- Architecture: HIGH - Existing code clearly shows pattern
- Pitfalls: HIGH - Based on Room's known behavior and multi-identity setup
- Test strategy: HIGH - Test infrastructure exists and patterns documented

**Research date:** 2026-01-27
**Valid until:** 2026-02-27 (30 days - stable domain, no framework changes expected)

**Notes:**
- This is a codebase-internal fix, not dependent on external library updates
- Room 2.6.1 is stable and well-tested with subqueries
- The fix is low-risk: if subquery fails, it defaults to no deletion (safe behavior)
- All change points identified with exact file paths and line numbers
