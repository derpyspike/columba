---
phase: 04-relay-loop-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt
autonomous: true

must_haves:
  truths:
    - "StateFlows stop collecting from Room when no UI observers are present"
    - "StateFlows survive configuration changes (5-second grace period)"
    - "Relay selection behavior unchanged when UI is actively observing"
  artifacts:
    - path: "app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt"
      provides: "StateFlow configuration for relay state management"
      contains: "SharingStarted.WhileSubscribed(5000L)"
  key_links:
    - from: "currentRelayState"
      to: "Room database via contactRepository.getMyRelayFlow()"
      via: "stateIn with WhileSubscribed"
      pattern: "currentRelayState.*stateIn.*WhileSubscribed"
    - from: "currentRelay"
      to: "currentRelayState"
      via: "stateIn with WhileSubscribed (consistent with parent)"
      pattern: "currentRelay.*stateIn.*WhileSubscribed"
    - from: "availableRelaysState"
      to: "Room database via announceRepository.getTopPropagationNodes"
      via: "stateIn with WhileSubscribed"
      pattern: "availableRelaysState.*stateIn.*WhileSubscribed"
---

<objective>
Change StateFlow sharing strategy from Eagerly to WhileSubscribed(5000L) for three relay-related StateFlows in PropagationNodeManager

Purpose: The v0.7.3 fix addressed the symptom (rapid re-selection via state machine) but not the root cause: SharingStarted.Eagerly keeps Room database observation active indefinitely, causing continuous reactive churn that triggers edge cases the state machine guard doesn't fully prevent. WhileSubscribed stops upstream collection when no UI observers are present.

Output: PropagationNodeManager with lifecycle-aware StateFlow sharing that eliminates unnecessary database observation during background operation
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-relay-loop-resolution/04-RESEARCH.md
@app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update StateFlow sharing strategy to WhileSubscribed</name>
  <files>app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt</files>
  <action>
Change three StateFlow declarations from SharingStarted.Eagerly to SharingStarted.WhileSubscribed(5000L):

1. **currentRelayState** (around line 202):
   - Change: `.stateIn(scope, SharingStarted.Eagerly, RelayLoadState.Loading)`
   - To: `.stateIn(scope, SharingStarted.WhileSubscribed(5000L), RelayLoadState.Loading)`

2. **currentRelay** (around line 212):
   - Change: `.stateIn(scope, SharingStarted.Eagerly, null)`
   - To: `.stateIn(scope, SharingStarted.WhileSubscribed(5000L), null)`

3. **availableRelaysState** (around line 236):
   - Change: `.stateIn(scope, SharingStarted.Eagerly, AvailableRelaysState.Loading)`
   - To: `.stateIn(scope, SharingStarted.WhileSubscribed(5000L), AvailableRelaysState.Loading)`

The 5000L timeout (5 seconds) is the standard Android recommendation - it survives configuration changes (screen rotation typically &lt;2 seconds) without restarting upstream unnecessarily.

DO NOT modify:
- The state machine (IDLE/SELECTING/STABLE/BACKING_OFF) - remains as defense-in-depth
- The debounce(1000) on the announce Flow - still valuable for batching
- The loop detection with recordSelection() - still valuable for edge cases
- The 30-second cooldown after selection - still valuable for stability
  </action>
  <verify>
1. Run: `grep -n "SharingStarted.WhileSubscribed" app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt`
   Expected: 3 matches (lines ~202, ~212, ~236)

2. Run: `grep -n "SharingStarted.Eagerly" app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt`
   Expected: 0 matches (none remaining)
  </verify>
  <done>
- currentRelayState uses SharingStarted.WhileSubscribed(5000L)
- currentRelay uses SharingStarted.WhileSubscribed(5000L)
- availableRelaysState uses SharingStarted.WhileSubscribed(5000L)
- No SharingStarted.Eagerly remaining in PropagationNodeManager
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify build and existing tests pass</name>
  <files>app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt</files>
  <action>
Run the project build and PropagationNodeManager tests to verify the change doesn't break existing functionality.

1. Build the project to verify no compilation errors
2. Run PropagationNodeManager unit tests to verify state machine behavior is unchanged

The existing tests use mocked StateFlows in the test setup, so they don't directly test the SharingStarted strategy. However, they verify the core state machine logic remains intact.
  </action>
  <verify>
1. Run: `cd /home/tyler/repos/public/columba-issue-342-map-location-dialog && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugKotlin`
   Expected: BUILD SUCCESSFUL

2. Run: `cd /home/tyler/repos/public/columba-issue-342-map-location-dialog && JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:testDebugUnitTest --tests "com.lxmf.messenger.service.PropagationNodeManagerTest"`
   Expected: All tests pass
  </verify>
  <done>
- Project compiles successfully with WhileSubscribed changes
- All PropagationNodeManager unit tests pass
- No regressions in state machine behavior
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Code verification:**
   - `grep -c "WhileSubscribed(5000L)" app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt` returns 3
   - `grep -c "SharingStarted.Eagerly" app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt` returns 0

2. **Build verification:**
   - Project compiles without errors
   - PropagationNodeManager unit tests pass

3. **Pattern verification:**
   - State machine (IDLE/SELECTING/STABLE/BACKING_OFF) unchanged
   - debounce(1000) on announce Flow unchanged
   - Loop detection with recordSelection unchanged
</verification>

<success_criteria>
- [ ] Three StateFlows changed from Eagerly to WhileSubscribed(5000L)
- [ ] Zero instances of SharingStarted.Eagerly in PropagationNodeManager
- [ ] Build succeeds with no compilation errors
- [ ] All PropagationNodeManager unit tests pass
- [ ] Phase 2 defense-in-depth mechanisms preserved (state machine, debounce, loop detection)
</success_criteria>

<output>
After completion, create `.planning/phases/04-relay-loop-resolution/04-01-SUMMARY.md`
</output>
