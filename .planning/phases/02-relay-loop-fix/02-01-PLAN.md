---
phase: 02-relay-loop-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt
autonomous: true

must_haves:
  truths:
    - "Auto-selection logic does not run while already selecting or in cooldown"
    - "Database-triggered Flow emissions are debounced to prevent rapid-fire selection"
    - "User manual selection immediately cancels ongoing auto-selection"
  artifacts:
    - path: "app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt"
      provides: "State machine for relay selection (IDLE, SELECTING, STABLE)"
      contains: "RelaySelectionState"
  key_links:
    - from: "observePropagationNodeAnnounces()"
      to: "_selectionState guard clause"
      via: "state check before selection logic"
      pattern: "if.*_selectionState\\.value.*!=.*IDLE"
---

<objective>
Add state machine to PropagationNodeManager to prevent relay selection feedback loop.

Purpose: The relay auto-selection loop (#343) is caused by reactive Flows triggering database updates which re-trigger the Flows. This plan adds explicit state tracking (IDLE, SELECTING, STABLE) with cooldown to break the loop.

Output: PropagationNodeManager with state machine that prevents re-entrant selection logic.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-relay-loop-fix/02-CONTEXT.md
@.planning/phases/02-relay-loop-fix/02-RESEARCH.md

Key source file:
@app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add RelaySelectionState enum and state tracking</name>
  <files>app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt</files>
  <action>
Add RelaySelectionState enum at the top of the file (after existing sealed classes):

```kotlin
/**
 * State machine for relay auto-selection process.
 * Prevents feedback loops by tracking selection lifecycle.
 */
enum class RelaySelectionState {
    /** Ready to auto-select. Only state where selection can trigger. */
    IDLE,
    /** Selection triggered, waiting for database update to complete. */
    SELECTING,
    /** Relay selected and stable. Cooldown active before returning to IDLE. */
    STABLE
}
```

Add state tracking in PropagationNodeManager class (after companion object):

```kotlin
// State machine to prevent relay selection feedback loops
private val _selectionState = MutableStateFlow(RelaySelectionState.IDLE)
val selectionState: StateFlow<RelaySelectionState> = _selectionState.asStateFlow()

// Cooldown duration after successful selection (30 seconds per context decisions)
private val selectionCooldownMs = 30_000L

// Job for cooldown timer (cancellable if user takes manual action)
private var cooldownJob: Job? = null
```

Import MutableStateFlow if not already imported (it is, just verify).
  </action>
  <verify>
Build compiles: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugKotlin 2>&1 | tail -20`
Look for BUILD SUCCESSFUL or specific error in PropagationNodeManager.kt
  </verify>
  <done>RelaySelectionState enum exists, _selectionState MutableStateFlow initialized in PropagationNodeManager</done>
</task>

<task type="auto">
  <name>Task 2: Add debounce and state guard to observePropagationNodeAnnounces</name>
  <files>app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt</files>
  <action>
Modify observePropagationNodeAnnounces() to add debounce and state guard.

**Before (current code lines 695-729):**
```kotlin
private suspend fun observePropagationNodeAnnounces() {
    announceRepository.getAnnouncesByTypes(listOf("PROPAGATION_NODE")).collect { propagationNodes ->
        // ... existing logic
    }
}
```

**After:**
```kotlin
private suspend fun observePropagationNodeAnnounces() {
    announceRepository.getAnnouncesByTypes(listOf("PROPAGATION_NODE"))
        .debounce(1000) // Batch rapid Room invalidation triggers (per research)
        .collect { propagationNodes ->
            // CRITICAL: Don't trigger selection if already selecting or in cooldown
            if (_selectionState.value != RelaySelectionState.IDLE) {
                Log.d(TAG, "Skipping auto-select - state=${_selectionState.value}")
                return@collect
            }

            val isAutoSelect = settingsRepository.getAutoSelectPropagationNode()

            Log.d(
                TAG,
                "observePropagationNodeAnnounces: isAutoSelect=$isAutoSelect, " +
                    "availableNodes=${propagationNodes.size}, state=${_selectionState.value}",
            )

            if (isAutoSelect && propagationNodes.isNotEmpty()) {
                // Transition to SELECTING state BEFORE any selection logic
                _selectionState.value = RelaySelectionState.SELECTING
                Log.i(TAG, "Relay selection started (state=SELECTING)")

                // Find the nearest propagation node
                val nearest = propagationNodes.minByOrNull { it.hops }
                if (nearest != null) {
                    Log.i(
                        TAG,
                        "Auto-selecting nearest relay: ${nearest.peerName} " +
                            "(${nearest.destinationHash.take(12)}...) at ${nearest.hops} hops",
                    )
                    onPropagationNodeAnnounce(
                        nearest.destinationHash,
                        nearest.peerName,
                        nearest.hops,
                        nearest.publicKey,
                    )

                    // Transition to STABLE and start cooldown
                    _selectionState.value = RelaySelectionState.STABLE
                    Log.i(TAG, "Relay selection complete (state=STABLE), cooldown=${selectionCooldownMs}ms")

                    // Start cooldown timer
                    cooldownJob?.cancel() // Cancel any existing cooldown
                    cooldownJob = scope.launch {
                        delay(selectionCooldownMs)
                        if (_selectionState.value == RelaySelectionState.STABLE) {
                            _selectionState.value = RelaySelectionState.IDLE
                            Log.d(TAG, "Relay selection cooldown complete (state=IDLE)")
                        }
                    }
                } else {
                    // No nearest found (shouldn't happen if list is non-empty, but safety)
                    _selectionState.value = RelaySelectionState.IDLE
                    Log.w(TAG, "Auto-select enabled but no nearest node found, returning to IDLE")
                }
            } else if (isAutoSelect && propagationNodes.isEmpty()) {
                Log.w(
                    TAG,
                    "Auto-select enabled but no valid propagation nodes available. " +
                        "Nodes with deprecated announce format (stampCostFlexibility=NULL) are filtered out.",
                )
            }
        }
}
```

Add import at top of file:
```kotlin
import kotlinx.coroutines.flow.debounce
```
  </action>
  <verify>
Build compiles: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugKotlin 2>&1 | tail -20`
Verify debounce import and state machine logic added.
  </verify>
  <done>observePropagationNodeAnnounces uses debounce(1000) and checks _selectionState before running selection logic</done>
</task>

<task type="auto">
  <name>Task 3: Add user action precedence to setManualRelay and clearRelay</name>
  <files>app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt</files>
  <action>
Modify setManualRelay() to cancel auto-selection immediately when user takes manual action.

**In setManualRelay() (around line 524), add at the start of the function:**
```kotlin
suspend fun setManualRelay(
    destinationHash: String,
    displayName: String,
) {
    // Cancel any ongoing auto-selection - user action takes precedence
    if (_selectionState.value != RelaySelectionState.IDLE) {
        Log.i(TAG, "User manual selection - cancelling auto-select (state was ${_selectionState.value})")
        cooldownJob?.cancel()
    }
    _selectionState.value = RelaySelectionState.IDLE // User action always resets to IDLE

    Log.i(TAG, "User manually selected relay: $displayName")
    // ... rest of existing code unchanged
```

**Similarly modify setManualRelayByHash() (around line 591):**
```kotlin
suspend fun setManualRelayByHash(
    destinationHash: String,
    nickname: String?,
) {
    // Cancel any ongoing auto-selection - user action takes precedence
    if (_selectionState.value != RelaySelectionState.IDLE) {
        Log.i(TAG, "User manual relay by hash - cancelling auto-select (state was ${_selectionState.value})")
        cooldownJob?.cancel()
    }
    _selectionState.value = RelaySelectionState.IDLE

    Log.i(TAG, "User manually entered relay hash: $destinationHash")
    // ... rest of existing code unchanged
```

**Modify clearRelay() (around line 575):**
```kotlin
suspend fun clearRelay() {
    // Cancel any ongoing auto-selection
    cooldownJob?.cancel()
    _selectionState.value = RelaySelectionState.IDLE

    Log.i(TAG, "Clearing relay selection")
    // ... rest of existing code unchanged
```

**Modify enableAutoSelect() (around line 548):**
```kotlin
suspend fun enableAutoSelect() {
    // Reset state when enabling auto-select
    cooldownJob?.cancel()
    _selectionState.value = RelaySelectionState.IDLE

    Log.i(TAG, "Enabling auto-select for propagation node")
    // ... rest of existing code unchanged
```
  </action>
  <verify>
Build compiles: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugKotlin 2>&1 | tail -20`
  </verify>
  <done>setManualRelay, setManualRelayByHash, clearRelay, and enableAutoSelect all reset _selectionState and cancel cooldownJob</done>
</task>

</tasks>

<verification>
After all tasks:
1. Build succeeds: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugKotlin`
2. Unit tests pass: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:testDebugUnitTest --tests "com.lxmf.messenger.service.PropagationNodeManagerTest" 2>&1 | tail -50`
3. Grep confirms state machine present: `grep -n "RelaySelectionState" app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt`
4. Grep confirms debounce added: `grep -n "debounce" app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt`
</verification>

<success_criteria>
- RelaySelectionState enum exists with IDLE, SELECTING, STABLE states
- observePropagationNodeAnnounces() has debounce(1000) and state guard
- User action methods (setManualRelay, clearRelay, enableAutoSelect) reset state machine
- Build compiles successfully
- Existing unit tests pass (or have expected failures unrelated to this change)
</success_criteria>

<output>
After completion, create `.planning/phases/02-relay-loop-fix/02-01-SUMMARY.md`
</output>
