---
phase: 02-relay-loop-fix
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/src/test/java/com/lxmf/messenger/service/PropagationNodeManagerTest.kt
autonomous: true

must_haves:
  truths:
    - "Unit tests verify state machine transitions (IDLE -> SELECTING -> STABLE -> IDLE)"
    - "Unit tests verify state guard prevents selection when not IDLE"
    - "Unit tests verify debounce effect on rapid Flow emissions"
    - "Unit tests verify user action cancels auto-selection"
  artifacts:
    - path: "app/src/test/java/com/lxmf/messenger/service/PropagationNodeManagerTest.kt"
      provides: "State machine and loop prevention tests"
      contains: "selectionState"
  key_links:
    - from: "test"
      to: "PropagationNodeManager"
      via: "MockK + Turbine verification"
      pattern: "selectionState.*test"
---

<objective>
Add unit tests for relay selection state machine and loop prevention logic.

Purpose: Verify the state machine correctly prevents feedback loops through automated tests. Tests ensure state transitions work as designed and that guard clauses prevent re-entrant selection.

Output: Comprehensive unit tests for RelaySelectionState transitions and loop prevention.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-relay-loop-fix/02-CONTEXT.md
@.planning/phases/02-relay-loop-fix/02-01-SUMMARY.md

Key test file:
@app/src/test/java/com/lxmf/messenger/service/PropagationNodeManagerTest.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add state machine lifecycle tests</name>
  <files>app/src/test/java/com/lxmf/messenger/service/PropagationNodeManagerTest.kt</files>
  <action>
Add new test section at the end of the test file (before the closing class brace).
Use existing test patterns: MockK, Turbine, TestScope.

```kotlin
// ========== State Machine Tests (Phase 2 - Relay Loop Fix) ==========

@Test
fun `selectionState - starts as IDLE`() = runTest {
    // When: Manager is created
    // Then: Selection state should start as IDLE
    assertEquals(RelaySelectionState.IDLE, manager.selectionState.value)
}

@Test
fun `selectionState - transitions to STABLE after auto-selection`() = runTest {
    // Given: Auto-select enabled with propagation nodes available
    coEvery { settingsRepository.getAutoSelectPropagationNode() } returns true
    val announce = TestFactories.createAnnounce(
        destinationHash = testDestHash,
        nodeType = "PROPAGATION_NODE",
        hops = 2
    )
    val announcesFlow = MutableSharedFlow<List<com.lxmf.messenger.data.db.entity.AnnounceEntity>>()
    every { announceRepository.getAnnouncesByTypes(listOf("PROPAGATION_NODE")) } returns announcesFlow

    // When: Manager starts and receives announces
    manager.start()
    advanceUntilIdle()

    // Emit announces after debounce period
    announcesFlow.emit(listOf(announce))
    advanceUntilIdle()

    // Allow debounce (1000ms) + processing
    testScheduler.advanceTimeBy(1500)
    advanceUntilIdle()

    // Then: State should be STABLE (selection completed, in cooldown)
    manager.selectionState.test(timeout = 5.seconds) {
        val state = awaitItem()
        assertTrue(
            "Expected STABLE or IDLE, got $state",
            state == RelaySelectionState.STABLE || state == RelaySelectionState.IDLE
        )
        cancelAndIgnoreRemainingEvents()
    }

    manager.stop()
}

@Test
fun `selectionState - returns to IDLE after cooldown`() = runTest {
    // Given: Auto-select enabled with propagation nodes
    coEvery { settingsRepository.getAutoSelectPropagationNode() } returns true
    val announce = TestFactories.createAnnounce(
        destinationHash = testDestHash,
        nodeType = "PROPAGATION_NODE",
        hops = 2
    )
    val announcesFlow = MutableSharedFlow<List<com.lxmf.messenger.data.db.entity.AnnounceEntity>>()
    every { announceRepository.getAnnouncesByTypes(listOf("PROPAGATION_NODE")) } returns announcesFlow

    // When: Manager starts and processes selection
    manager.start()
    advanceUntilIdle()

    announcesFlow.emit(listOf(announce))
    advanceUntilIdle()

    // Advance past debounce (1s) + cooldown (30s) + buffer
    testScheduler.advanceTimeBy(35_000)
    advanceUntilIdle()

    // Then: State should return to IDLE after cooldown
    assertEquals(RelaySelectionState.IDLE, manager.selectionState.value)

    manager.stop()
}
```

Import RelaySelectionState at the top of the test file:
```kotlin
import com.lxmf.messenger.service.RelaySelectionState
```
  </action>
  <verify>
Unit tests compile: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugUnitTestKotlin 2>&1 | tail -20`
  </verify>
  <done>State machine lifecycle tests added for IDLE, STABLE, and cooldown transitions</done>
</task>

<task type="auto">
  <name>Task 2: Add state guard prevention tests</name>
  <files>app/src/test/java/com/lxmf/messenger/service/PropagationNodeManagerTest.kt</files>
  <action>
Add tests verifying that selection is blocked when not in IDLE state:

```kotlin
@Test
fun `auto-select - skips selection when state is not IDLE`() = runTest {
    // Given: Auto-select enabled with propagation nodes
    coEvery { settingsRepository.getAutoSelectPropagationNode() } returns true
    val announce = TestFactories.createAnnounce(
        destinationHash = testDestHash,
        nodeType = "PROPAGATION_NODE",
        hops = 2
    )
    val announcesFlow = MutableSharedFlow<List<com.lxmf.messenger.data.db.entity.AnnounceEntity>>()
    every { announceRepository.getAnnouncesByTypes(listOf("PROPAGATION_NODE")) } returns announcesFlow

    // When: Manager starts
    manager.start()
    advanceUntilIdle()

    // First emission triggers selection
    announcesFlow.emit(listOf(announce))
    testScheduler.advanceTimeBy(1500) // Past debounce
    advanceUntilIdle()

    // Record setAsMyRelay call count
    val callsAfterFirst = mutableListOf<String>()
    coEvery { contactRepository.setAsMyRelay(capture(callsAfterFirst), any()) } answers {
        myRelayFlow.value = TestFactories.createContactEntity(
            destinationHash = callsAfterFirst.last(),
            isMyRelay = true
        )
    }

    // Second emission should be blocked by state guard (still in STABLE/cooldown)
    val announce2 = TestFactories.createAnnounce(
        destinationHash = testDestHash2,
        nodeType = "PROPAGATION_NODE",
        hops = 1 // Lower hop count - would normally trigger switch
    )
    announcesFlow.emit(listOf(announce2))
    testScheduler.advanceTimeBy(1500)
    advanceUntilIdle()

    // Then: Second selection should NOT have called setAsMyRelay for testDestHash2
    // because state guard blocked it (state was STABLE, not IDLE)
    coVerify(atMost = 1) { contactRepository.setAsMyRelay(any(), any()) }

    manager.stop()
}

@Test
fun `setManualRelay - resets state to IDLE`() = runTest {
    // Given: Manager in some non-IDLE state (simulate by triggering auto-select)
    coEvery { settingsRepository.getAutoSelectPropagationNode() } returns true
    val announce = TestFactories.createAnnounce(
        destinationHash = testDestHash,
        nodeType = "PROPAGATION_NODE",
        hops = 2
    )
    val announcesFlow = MutableSharedFlow<List<com.lxmf.messenger.data.db.entity.AnnounceEntity>>()
    every { announceRepository.getAnnouncesByTypes(listOf("PROPAGATION_NODE")) } returns announcesFlow

    manager.start()
    advanceUntilIdle()

    // Trigger auto-select to get into STABLE state
    announcesFlow.emit(listOf(announce))
    testScheduler.advanceTimeBy(1500)
    advanceUntilIdle()

    // State should be STABLE
    assertTrue(
        "Expected STABLE, got ${manager.selectionState.value}",
        manager.selectionState.value == RelaySelectionState.STABLE ||
        manager.selectionState.value == RelaySelectionState.IDLE
    )

    // When: User manually selects a relay
    manager.setManualRelay(testDestHash2, "Manual Relay")
    advanceUntilIdle()

    // Then: State should be reset to IDLE (user action cancels auto-select)
    assertEquals(RelaySelectionState.IDLE, manager.selectionState.value)

    manager.stop()
}

@Test
fun `clearRelay - resets state to IDLE`() = runTest {
    // Given: Manager started
    manager.start()
    advanceUntilIdle()

    // When: Relay is cleared
    manager.clearRelay()
    advanceUntilIdle()

    // Then: State should be IDLE
    assertEquals(RelaySelectionState.IDLE, manager.selectionState.value)

    manager.stop()
}

@Test
fun `enableAutoSelect - resets state to IDLE`() = runTest {
    // Given: Manager started
    manager.start()
    advanceUntilIdle()

    // When: Auto-select is enabled
    manager.enableAutoSelect()
    advanceUntilIdle()

    // Then: State should be IDLE (ready for fresh auto-selection)
    assertEquals(RelaySelectionState.IDLE, manager.selectionState.value)

    manager.stop()
}
```
  </action>
  <verify>
Unit tests compile and run: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:testDebugUnitTest --tests "com.lxmf.messenger.service.PropagationNodeManagerTest.*state*" 2>&1 | tail -50`
  </verify>
  <done>State guard tests verify selection blocked when not IDLE, user actions reset state</done>
</task>

<task type="auto">
  <name>Task 3: Add debounce behavior tests</name>
  <files>app/src/test/java/com/lxmf/messenger/service/PropagationNodeManagerTest.kt</files>
  <action>
Add tests verifying debounce batches rapid emissions:

```kotlin
@Test
fun `auto-select - debounce batches rapid announce emissions`() = runTest {
    // Given: Auto-select enabled
    coEvery { settingsRepository.getAutoSelectPropagationNode() } returns true
    val announcesFlow = MutableSharedFlow<List<com.lxmf.messenger.data.db.entity.AnnounceEntity>>()
    every { announceRepository.getAnnouncesByTypes(listOf("PROPAGATION_NODE")) } returns announcesFlow

    // Track setAsMyRelay calls
    val relayCalls = mutableListOf<String>()
    coEvery { contactRepository.setAsMyRelay(capture(relayCalls), any()) } answers {
        myRelayFlow.value = TestFactories.createContactEntity(
            destinationHash = relayCalls.last(),
            isMyRelay = true
        )
    }

    // When: Manager starts
    manager.start()
    advanceUntilIdle()

    // Emit 5 rapid changes (simulating Room invalidation triggers)
    // These should be debounced into a single selection
    repeat(5) { i ->
        val announce = TestFactories.createAnnounce(
            destinationHash = testDestHash,
            nodeType = "PROPAGATION_NODE",
            hops = 2 + i // Different hop counts
        )
        announcesFlow.emit(listOf(announce))
        testScheduler.advanceTimeBy(100) // 100ms between emissions (within 1s debounce)
        advanceUntilIdle()
    }

    // Advance past debounce period
    testScheduler.advanceTimeBy(2000)
    advanceUntilIdle()

    // Then: Only ONE selection should have been made (debounce batched the rapid emissions)
    // The last emitted value should be processed
    assertTrue(
        "Expected at most 1 setAsMyRelay call (debounce should batch), got ${relayCalls.size}",
        relayCalls.size <= 1
    )

    manager.stop()
}

@Test
fun `auto-select - processes emission after debounce delay`() = runTest {
    // Given: Auto-select enabled
    coEvery { settingsRepository.getAutoSelectPropagationNode() } returns true
    val announcesFlow = MutableSharedFlow<List<com.lxmf.messenger.data.db.entity.AnnounceEntity>>()
    every { announceRepository.getAnnouncesByTypes(listOf("PROPAGATION_NODE")) } returns announcesFlow

    val announce = TestFactories.createAnnounce(
        destinationHash = testDestHash,
        nodeType = "PROPAGATION_NODE",
        hops = 2
    )

    // Track setAsMyRelay calls
    var setAsMyRelayCalled = false
    coEvery { contactRepository.setAsMyRelay(any(), any()) } answers {
        setAsMyRelayCalled = true
        myRelayFlow.value = TestFactories.createContactEntity(
            destinationHash = testDestHash,
            isMyRelay = true
        )
    }

    // When: Manager starts
    manager.start()
    advanceUntilIdle()

    // Emit announces
    announcesFlow.emit(listOf(announce))
    advanceUntilIdle()

    // Before debounce delay - should NOT have processed yet
    testScheduler.advanceTimeBy(500) // Less than 1000ms debounce
    advanceUntilIdle()
    // Selection might not have happened yet

    // After debounce delay - should process
    testScheduler.advanceTimeBy(1000) // Total 1500ms > 1000ms debounce
    advanceUntilIdle()

    // Then: Selection should have been made
    assertTrue("Expected setAsMyRelay to be called after debounce", setAsMyRelayCalled)

    manager.stop()
}
```
  </action>
  <verify>
All state machine tests pass: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:testDebugUnitTest --tests "com.lxmf.messenger.service.PropagationNodeManagerTest" 2>&1 | tail -50`
  </verify>
  <done>Debounce tests verify rapid emissions are batched, processing happens after delay</done>
</task>

</tasks>

<verification>
After all tasks:
1. All tests compile: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugUnitTestKotlin`
2. State machine tests pass: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:testDebugUnitTest --tests "com.lxmf.messenger.service.PropagationNodeManagerTest.*state*" --tests "com.lxmf.messenger.service.PropagationNodeManagerTest.*debounce*"`
3. All PropagationNodeManager tests pass: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:testDebugUnitTest --tests "com.lxmf.messenger.service.PropagationNodeManagerTest"`
</verification>

<success_criteria>
- State machine lifecycle tests verify IDLE -> STABLE -> IDLE transitions
- State guard tests verify selection blocked when not IDLE
- User action tests verify setManualRelay/clearRelay/enableAutoSelect reset state
- Debounce tests verify rapid emissions batched
- All new tests pass
- Existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-relay-loop-fix/02-03-SUMMARY.md`
</output>
