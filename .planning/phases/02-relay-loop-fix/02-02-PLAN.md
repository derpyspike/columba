---
phase: 02-relay-loop-fix
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt
autonomous: true

must_haves:
  truths:
    - "3+ relay changes in 60 seconds triggers warning log and state transition to BACKING_OFF"
    - "BACKING_OFF state uses exponential backoff (1s, 2s, 4s... max 10 min)"
    - "Sentry event is sent when loop detected"
    - "Logs include reason for selection (startup, previous unreachable, loop detected)"
  artifacts:
    - path: "app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt"
      provides: "Loop detection and backoff logic"
      contains: "recordSelection"
  key_links:
    - from: "observePropagationNodeAnnounces()"
      to: "recordSelection()"
      via: "called after each selection"
      pattern: "recordSelection"
---

<objective>
Add loop detection, exponential backoff, and diagnostic logging to PropagationNodeManager.

Purpose: Defense-in-depth against relay selection loops. Even with state machine, edge cases could cause rapid cycling. This plan adds loop detection that triggers exponential backoff and sends Sentry events for diagnostics.

Output: PropagationNodeManager with loop detection, BACKING_OFF state, and enhanced logging.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-relay-loop-fix/02-CONTEXT.md
@.planning/phases/02-relay-loop-fix/02-RESEARCH.md
@.planning/phases/02-relay-loop-fix/02-01-SUMMARY.md

Key source file:
@app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BACKING_OFF state and loop detection infrastructure</name>
  <files>app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt</files>
  <action>
Update RelaySelectionState enum to include BACKING_OFF state:

```kotlin
enum class RelaySelectionState {
    /** Ready to auto-select. Only state where selection can trigger. */
    IDLE,
    /** Selection triggered, waiting for database update to complete. */
    SELECTING,
    /** Relay selected and stable. Cooldown active before returning to IDLE. */
    STABLE,
    /** Loop detected. Exponential backoff in progress before returning to IDLE. */
    BACKING_OFF
}
```

Add loop detection infrastructure in PropagationNodeManager class (after cooldownJob):

```kotlin
// Loop detection: track recent selections to detect rapid cycling
// Per context decisions: 3+ changes in 60 seconds triggers warning
private val recentSelections = ArrayDeque<Pair<String, Long>>()
private val loopThresholdCount = 3
private val loopWindowMs = 60_000L
private val maxBackoffMs = 10 * 60 * 1000L // 10 minutes max (per context decisions)

// Job for backoff timer
private var backoffJob: Job? = null
```

Add the import for ArrayDeque if not present (it's in kotlin.collections, should be automatic).
  </action>
  <verify>
Build compiles: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugKotlin 2>&1 | tail -20`
  </verify>
  <done>BACKING_OFF state added to enum, loop detection variables initialized</done>
</task>

<task type="auto">
  <name>Task 2: Add recordSelection function with loop detection logic</name>
  <files>app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt</files>
  <action>
Add recordSelection function after the loop detection infrastructure (before observePropagationNodeAnnounces):

```kotlin
/**
 * Record a relay selection for loop detection.
 * If 3+ selections happen within 60 seconds, triggers BACKING_OFF state.
 *
 * @param destinationHash The selected relay's destination hash
 * @param reason Reason for selection (for logging)
 */
private suspend fun recordSelection(destinationHash: String, reason: String) {
    val now = System.currentTimeMillis()

    // Record this selection
    recentSelections.addLast(destinationHash to now)

    // Keep only last 10 entries to bound memory
    while (recentSelections.size > 10) {
        recentSelections.removeFirst()
    }

    // Count selections within the loop detection window
    val windowStart = now - loopWindowMs
    val recentCount = recentSelections.count { it.second > windowStart }

    Log.i(TAG, "Relay selected: ${destinationHash.take(12)}... ($reason) [${recentCount}x in last 60s]")

    if (recentCount >= loopThresholdCount) {
        val hashes = recentSelections
            .filter { it.second > windowStart }
            .map { it.first.take(12) }

        Log.w(TAG, "⚠️ Relay loop detected! $recentCount selections in 60s: $hashes")

        // Send Sentry event for diagnostics (per context decisions)
        // The Sentry integration was added in Phase 1 (01-03-PLAN.md)
        try {
            io.sentry.Sentry.captureMessage(
                "Relay selection loop detected: $recentCount selections in 60s",
                io.sentry.SentryLevel.WARNING
            )
            io.sentry.Sentry.addBreadcrumb(
                io.sentry.Breadcrumb().apply {
                    category = "relay"
                    message = "Loop detected: hashes=$hashes"
                    level = io.sentry.SentryLevel.WARNING
                }
            )
        } catch (e: Exception) {
            Log.w(TAG, "Failed to send Sentry event: ${e.message}")
        }

        // Transition to BACKING_OFF state
        _selectionState.value = RelaySelectionState.BACKING_OFF

        // Calculate exponential backoff: 1s, 2s, 4s, 8s... max 10 minutes
        // Formula: 2^(recentCount - loopThreshold) seconds, capped at max
        val exponent = (recentCount - loopThresholdCount).coerceAtLeast(0)
        val backoffMs = minOf(
            (1L shl exponent) * 1000L, // 2^exponent * 1000ms
            maxBackoffMs
        )

        Log.w(TAG, "Entering backoff for ${backoffMs / 1000}s (exponent=$exponent)")

        // Start backoff timer
        backoffJob?.cancel()
        backoffJob = scope.launch {
            delay(backoffMs)
            if (_selectionState.value == RelaySelectionState.BACKING_OFF) {
                _selectionState.value = RelaySelectionState.IDLE
                Log.i(TAG, "Backoff complete, returning to IDLE")
            }
        }
    }
}
```

Add Sentry imports at top of file:
```kotlin
import io.sentry.Sentry
import io.sentry.SentryLevel
import io.sentry.Breadcrumb
```

Note: The Sentry SDK was integrated in Phase 1 Plan 03. If Sentry is not available in this module, wrap in try-catch (already done above).
  </action>
  <verify>
Build compiles: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugKotlin 2>&1 | tail -20`
  </verify>
  <done>recordSelection function exists with loop detection, Sentry integration, and exponential backoff</done>
</task>

<task type="auto">
  <name>Task 3: Integrate recordSelection into selection flow and update state checks</name>
  <files>app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt</files>
  <action>
**Update observePropagationNodeAnnounces to call recordSelection after successful selection.**

In the existing state machine code (added in Plan 01), after `onPropagationNodeAnnounce()` call but before transitioning to STABLE, add:

```kotlin
// Record for loop detection BEFORE transitioning to STABLE
recordSelection(nearest.destinationHash, "auto-select")

// Transition to STABLE and start cooldown
_selectionState.value = RelaySelectionState.STABLE
```

**Update the state guard to also check for BACKING_OFF:**

The existing guard `if (_selectionState.value != RelaySelectionState.IDLE)` already handles this since BACKING_OFF != IDLE, but update the log message to be clearer:

```kotlin
if (_selectionState.value != RelaySelectionState.IDLE) {
    Log.d(TAG, "Skipping auto-select - state=${_selectionState.value} (only IDLE allows selection)")
    return@collect
}
```

**Update onRelayDeleted to record selection:**

In onRelayDeleted(), after the `onPropagationNodeAnnounce()` call, add:

```kotlin
if (nearest != null) {
    Log.i(TAG, "Auto-selecting new relay: ${nearest.peerName} at ${nearest.hops} hops")
    onPropagationNodeAnnounce(
        nearest.destinationHash,
        nearest.peerName,
        nearest.hops,
        nearest.publicKey,
    )
    // Record for loop detection
    recordSelection(nearest.destinationHash, "relay-deleted")
}
```

**Update enableAutoSelect to record selection:**

In enableAutoSelect(), after the `onPropagationNodeAnnounce()` call, add:

```kotlin
if (nearest != null) {
    onPropagationNodeAnnounce(
        nearest.destinationHash,
        nearest.peerName,
        nearest.hops,
        nearest.publicKey,
    )
    // Record for loop detection
    recordSelection(nearest.destinationHash, "auto-select-enabled")
}
```

**Update stop() to cancel backoffJob:**

```kotlin
fun stop() {
    Log.d(TAG, "Stopping PropagationNodeManager")
    relayObserverJob?.cancel()
    announceObserverJob?.cancel()
    syncJob?.cancel()
    settingsObserverJob?.cancel()
    propagationStateObserverJob?.cancel()
    cooldownJob?.cancel()  // Already should be here from Plan 01
    backoffJob?.cancel()   // NEW: cancel backoff job
    // ... existing null assignments
    cooldownJob = null
    backoffJob = null
}
```
  </action>
  <verify>
Build compiles: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugKotlin 2>&1 | tail -20`
Grep for recordSelection calls: `grep -n "recordSelection" app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt`
  </verify>
  <done>recordSelection called from all selection paths, backoffJob canceled in stop()</done>
</task>

</tasks>

<verification>
After all tasks:
1. Build succeeds: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:compileDebugKotlin`
2. Unit tests pass: `JAVA_HOME=/home/tyler/android-studio/jbr ./gradlew :app:testDebugUnitTest --tests "com.lxmf.messenger.service.PropagationNodeManagerTest" 2>&1 | tail -50`
3. Grep confirms loop detection: `grep -n "loopThreshold\|BACKING_OFF\|recordSelection" app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt`
4. Grep confirms Sentry integration: `grep -n "Sentry.capture\|SentryLevel" app/src/main/java/com/lxmf/messenger/service/PropagationNodeManager.kt`
</verification>

<success_criteria>
- BACKING_OFF state added to RelaySelectionState enum
- recordSelection function implements loop detection (3+ in 60s threshold)
- Exponential backoff calculation correct (2^n seconds, max 10 minutes)
- Sentry.captureMessage called when loop detected
- All selection paths call recordSelection with reason
- stop() cancels backoffJob
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-relay-loop-fix/02-02-SUMMARY.md`
</output>
